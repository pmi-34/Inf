% Это комментарий
% Комментарии начинаются с символа %
% Формат А4, стиль - отчет
\documentclass[a4paper,12pt]{report}
% Поля - 2 сантиметра с каждой стороны, без места на подшивку
\usepackage[
  left   = 1cm,
  right  = 1cm,
  top    = 1cm,
  bottom = 2cm,
  bindingoffset = 0cm
]{geometry}
% Входная кодировка - UTF-8
\usepackage[utf8]{inputenc}
% Язык текста - русский и английский. Русский - основной
\usepackage[english,russian]{babel}
% Для команды \Box и других математических
\usepackage{amsfonts}
% Исправляем таблицы
\usepackage{float}
\restylefloat{table}
% Для вставки изображений
\usepackage{graphicx}
% Для вставки исходного кода
\usepackage{listings}
% Настройки листингов
\lstloadlanguages{Pascal}
\lstset{
language=Pascal,
extendedchars=\true,
inputencoding=utf8,
commentstyle=\itshape,
stringstyle=\bf,
belowcaptionskip=5pt,
keepspaces=true
}
% Используем графы
\usepackage{tikz}
\usetikzlibrary{snakes,arrows,shapes}
% Первый абзац должен начинаться с красной строки
\usepackage{indentfirst}
% Мы не используем главы, поэтому подправим номера секций
\renewcommand{\thesection}{\arabic{section}.}
% Сокращение для стрелочки
\renewcommand{\a}{\rightarrow}
\newcommand{\A}{\Rightarrow}
\renewcommand{\b}{\fbox}
% Исправим досадную ошибку с неразрывным пробелом в UTF-8
\DeclareUnicodeCharacter{00A0}{~}
% Моя команда для вставки кода
\DeclareRobustCommand{\clist}[1]
{
  \lstinputlisting[mathescape]{#1}
}
% Команда, описывающая задание
\DeclareRobustCommand{\task}[1]
{
  {\bf Задание #1}
  \par
}
% Подчеркнутые вопросы
\DeclareRobustCommand{\unitem}[1]
{
  \item {\it #1} \\
}
\DeclareRobustCommand{\mynote}
{
  {\bf УЕБАТЬ СУКА КУВАЛДОЙ ПО ПИЗДЕ ДРОЧЕНОЙ ТОЙ ПРОМУДОБЛЯДИНЕ, ЧТО
  ВЫБЛЯЕБСТВО ЭТО РОДИЛА!!!}\\
}
% Поправим отступы у списков
% Нумерованные списки в виде а)
\usepackage{enumitem}
\AddEnumerateCounter{\Asbuk}{\@Asbuk}{\CYRM}
\AddEnumerateCounter{\asbuk}{\@asbuk}{\cyrm}
\setlist[enumerate,1]{leftmargin=\dimexpr 26pt-.5in,label=\arabic{enumi}.}
\setlist[enumerate,2]{label=\asbuk{enumii})}
\setlist[enumerate,3]{label=\asbuk{enumiii})}

\begin{document}
\begin{center}
{\large \bf Лабораторная работа \No 5}

{\it Вариант \No 1}
\end{center}
{\it Во всех вариантах используются следующие описания:}
\clist{0.pas}
\task{1}
Дана процедура, осуществляющая сортировку массива.
\clist{1-0.pas}
{\it Ответьте на следующие вопросы.}
\begin{enumerate}[leftmargin = 10pt]
\unitem{Какой метод сортировки реализует процедура Sort?}
Это сортировка выбором.
\unitem{Сортировка осуществляется по возрастанию или по убыванию?}
Сортировка осуществляется по убыванию.
\unitem{Где накапливается отсортированная часть массива (в его конце или
начале)?}
Отсортированная часть накапливается в начале массива.
\unitem{Определите порядок сложности данной процедуры сортировки, вычислив 
порядок для функций M(n), характеризующей число пересылок, и С(n), 
характеризующей число сравнений элементов массива.}
Количество элементарных операций зависит, в первую очередь, от размера 
сортируемого массива. Однако величина n не определяет это количество 
однозначно. Для различных массивов одного и того же размера тело 
условного оператора будет выполняться различное число раз. Поэтому 
необходимы три оценки сложности: минимальная, максимальная и средняя.\\
{\bf Минимальная сложность} получается в том случае, когда элементы 
упорядочиваемого массива уже располагаются в нужном порядке. Тогда проверки 
A[j].key > x.key всегда будут давать отрицательный результат и тело условного
оператора не выполнится ни разу. Тогда выполнение процедуры сведется к выполнению 
следующих операторов:
\clist{1-1.pas}
Тело внешнего цикла {\bf For} исполняется точно $n-1$ раз, и число пересылок записей
(присваиваний из/в элементы массива): 
$M_{min} = 4(n-1)$.\\
Тело вложенного цикла {\bf For} выполняется 
при $i = 1~n-1$ раз, при $i = 2~n-2$ раза; при $i = n-1$ выполнится 1 раз.
Число сравнений ключей: $C = \sum\limits_{i=1}^{n-1}n-i = (1 + 2 +
3 + \dots + n-1) = \frac{n(n-1)}{2} = \frac{n^2 - n}{2}$.\\
{\bf Максимальная сложность} получается в том случае, когда элементы исходного 
массива расположены в порядке возрастания, и тело условного оператора будет
выполняться всегда. 
Количество пересылок записей:
$M_{max} = 4(n-1) + \sum\limits_{i=1}^{n-1}n-i = 4(n-1) + (1 + 2 + 3 + \dots +
n-1) = 4(n-1) + \frac{n(n-1)}{2} = \frac{n^2 + 7n - 8}{2}$.\\
Количество сравнений ключей будет тем же, что и для минимальной сложности.\\
{\bf Средняя оценка сложности} получится, если предположить, что все элементы
исходного массива - случайные числа. Результат очередной проверки в условном
операторе также является случайным, то есть мы можем считать, что его тело
будет выполняться с вероятностью $\frac{1}{2}$. Тогда: $M_{avg} = 
4(n-1) + \frac{1}{2}\sum\limits_{i=1}^{n-1}n-i = 4(n-1) +
\frac{1}{2}(1 + 2 + 3 + \dots + n-1) = 4(n-1) + \frac{n(n-1)}{4} = 
\frac{n^2 + 15n - 16}{4}$\\
Количество сравнений в данном случае также равно минимальному.
\unitem{При каком содержимом массива число операций пересылки будет
минимальным?}
Когда массив уже отсортирован по убыванию.
\unitem{Можно ли преобразовать процедуру сортировки так, чтобы минимальное число
пересылок стало меньше? Если можно, выполните оптимизацию данной процедуры.}
Можно заметить, что присваивание элементу x каждый раз нового значения -
пустая трата времени. Переписав условие оператора {\bf if}, получим возможность
избавиться от одного оператора присваивания вне вложенного цикла, одного -
во вложенном цикле и, в качестве приятного бонуса - от операторных скобок:
\clist{1-2.pas}
\unitem{Определите порядок сложности M(n) и С(n) для преобразованной процедуры
сортировки.}
Количество сравнений ключей в преобразованной процедуре не изменилось и
осталось равным $C = \frac{n^2 - n}{2}$.\\
Количество пересылок больше не зависит от условного оператора, и теперь
максимальная, минимальная и средняя сложность пересылки равны:
$M_{min} = M_{max} = M_{avg} = 3(n-1)$
\end{enumerate}
\task{2}
Дано описание процедуры сортировки на языке Паскаль. Нужно:
\begin{enumerate}[leftmargin = 10pt]
\unitem{определить какой метод сортировки она реализует (сортируемый массив
A, его размерность n)}
\mynote
Данный алгоритм представляет собой реализацию метода сортировки слияниями.
\unitem{провести пошаговое выполнение данной процедуры для массива А: [9,
2, 4, 3, 5, 1, 8, 7, 6]}
\input{5-2}
\begin{table}[H]
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
  \hline
    len & 
    A[1] & A[2] & A[3] & A[4] & A[5] & A[6] & A[7] & A[8] & A[9] \\
  \hline
    0 &
    9 & 2 & 4 & 3 & 5 & 1 & 8 & 7 & 6 \\
  \hline
    1 &
    |2 & 9| & |3 & 4| & |1 & 5| & |7 & 8| & |6| \\
  \hline
    2 &
    |2 & 3 & 4 & 9| & |1 & 5 & 7 & 8| & |6| \\
  \hline
    4 &
    |1 & 2 & 3 & 4 & 5 & 7 & 8 & 9| & |6| \\
  \hline
    8 &
    |1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9| \\
  \hline
\end{tabular}
\end{table}
\unitem{вставить комментарии в данный вариант сортировки, пояснив
назначение переменных и действия каждого блока программы}
\clist{2-1.pas}
\unitem{реализовать еще один (свой вариант) этой же сортировки
(предоставить листинг полученной программы с комментариями)}
\clist{2-2.pas}
\end{enumerate}

\end{document}
